<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Time Blocker Web App Prototype</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            width: 100vw;
            min-height: 100vh;
            overflow-x: hidden;
            background-color: #f3f4f6;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 20px;
        }
        #root {
            width: 100%;
            max-width: 1400px; /* Increased max-width for multi-day view */
        }
        /* Custom scrollbar for task lists */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #555;
            border-radius: 10px;
        }
        /* Removed color-swatch styles as color functionality is removed */
        /* Ensure time slot content grows */
        .time-slot-content {
            flex-grow: 1;
            min-height: 30px; /* Minimum height for droppable area */
        }

        /* Styles for resize handles */
        .resize-handle {
            position: absolute;
            left: 0;
            right: 0;
            height: 8px; /* Height of the handle */
            background-color: rgba(0, 0, 0, 0.2); /* Semi-transparent handle */
            cursor: ns-resize;
            z-index: 10; /* Above task content */
            opacity: 0; /* Hidden by default */
            transition: opacity 0.2s;
        }
        .scheduled-task-item:hover .resize-handle {
            opacity: 1; /* Show on hover */
        }
        .resize-handle-top {
            top: -4px; /* Half handle height outside for easier grab */
        }
        .resize-handle-bottom {
            bottom: -4px; /* Half handle height outside for easier grab */
        }

        /* Modal specific styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: white;
            padding: 24px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 400px;
            width: 90%;
        }

        /* Delete button style for tasks */
        .delete-task-button {
            position: absolute;
            top: 4px; /* Adjust as needed for padding/margin */
            right: 4px; /* Adjust as needed for padding/margin */
            background-color: rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.75rem; /* text-xs */
            font-weight: bold;
            color: #ef4444; /* red-500 */
            border: 1px solid #ef4444;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 15; /* Ensure it's above task content but below resize handles */
        }
        .scheduled-task-item:hover .delete-task-button {
            opacity: 1;
        }

        /* Day column fixed width for horizontal scrolling */
        .day-column {
            flex-shrink: 0; /* Prevent columns from shrinking */
            width: 300px; /* Fixed width for each day column */
        }

        /* Current time indicator line */
        .current-time-indicator {
            position: absolute;
            left: 0;
            right: 0;
            height: 2px; /* Thickness of the line */
            background-color: #ef4444; /* Red color */
            z-index: 20; /* Above tasks */
            pointer-events: none; /* Don't block clicks/drags on tasks */
        }
        .current-time-circle {
            position: absolute;
            left: -6px; /* Position circle slightly outside the line */
            top: -4px; /* Center vertically on the line */
            width: 10px;
            height: 10px;
            background-color: #ef4444; /* Red color */
            border-radius: 50%;
            border: 1px solid white; /* Small white border for visibility */
        }
        .current-time-label {
            position: absolute;
            left: 10px; /* Position label to the right of the circle */
            top: -8px; /* Adjust vertically */
            background-color: #ef4444;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: bold;
            white-space: nowrap;
        }

        /* Specific style for textarea inside task item to hide resize handle and ensure containment */
        /* Applying directly to the class for higher specificity */
        .scheduled-task-item textarea.task-info-textarea {
            box-sizing: border-box; /* Include padding and border in the element's total width and height */
            resize: none !important; /* Force no resize handle */
            overflow: hidden !important; /* Hide scrollbars if content overflows */
            padding: 4px; /* Add internal padding */
            border: 1px solid #d1d5db; /* Light grey border */
            border-radius: 4px; /* Rounded corners */
            display: block; /* Ensure it takes full width */
            width: 100%; /* Ensure it takes full width */
        }
        /* Style for the ghost task during drag */
        .scheduled-task-item.is-ghost {
            opacity: 0.5;
            border-style: dashed;
            background-color: #e0e7ff; /* light-blue-100 */
            pointer-events: none; /* Make it not interfere with other elements */
            z-index: 10; /* Keep it above time slots but below active drag item */
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="text/babel">
        // Utility function to format time for display (e.g., "09:00 AM")
        const formatTime = (date) => {
            return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        };

        // Utility function to format date for display (e.g., "Monday, January 10")
        const formatDate = (date) => {
            const options = { weekday: 'long', month: 'long', day: 'numeric' };
            return date.toLocaleDateString(undefined, options);
        };

        // Utility function to format date for header (e.g., "January 10, 2024")
        const formatFullDate = (date) => {
            const options = { year: 'numeric', month: 'long', day: 'numeric' };
            return date.toLocaleDateString(undefined, options);
        };

        // TaskItem Component - Represents a draggable task (for left panel)
        const TaskItem = ({ task, index, onDragStart, onDragEnd, onUpdateTaskName }) => {
            const [isEditingName, setIsEditingName] = React.useState(false);
            const [editedName, setEditedName] = React.useState(task.name);

            React.useEffect(() => {
                setEditedName(task.name);
            }, [task.name]);

            const handleNameChange = (e) => {
                setEditedName(e.target.value);
            };

            const handleNameBlur = () => {
                setIsEditingName(false);
                if (editedName.trim() !== task.name) {
                    onUpdateTaskName(task.id, editedName.trim(), 'left'); // 'left' to indicate it's from left panel
                }
            };

            const handleKeyDown = (e) => {
                if (e.key === 'Enter') {
                    e.target.blur(); // Trigger blur to save changes
                }
            };

            return (
                <div
                    id={`task-${task.id}`}
                    draggable="true"
                    onDragStart={(e) => onDragStart(e, task, index)}
                    onDragEnd={onDragEnd}
                    className="p-3 rounded-md shadow-sm border border-gray-200 mb-2 cursor-grab active:cursor-grabbing text-gray-800 text-sm flex flex-col relative group"
                    style={{ backgroundColor: '#ffffff' }}
                >
                    <div className="flex justify-between items-center">
                        {isEditingName ? (
                            <input
                                type="text"
                                value={editedName}
                                onChange={handleNameChange}
                                onBlur={handleNameBlur}
                                onKeyDown={handleKeyDown}
                                className="font-semibold w-full bg-gray-100 border border-gray-300 rounded-sm px-1"
                                autoFocus
                            />
                        ) : (
                            <span className="font-semibold cursor-text" onClick={() => setIsEditingName(true)}>
                                {task.name}
                            </span>
                        )}
                        {task.duration && (
                            <span className="text-xs text-gray-500 ml-2">
                                {task.duration} min
                            </span>
                        )}
                    </div>
                </div>
            );
        };

        // ScheduledTaskItem Component - Represents a task in the time slots (resizable and draggable)
        const ScheduledTaskItem = ({ task, onDragStart, onDragEnd, onScheduledTaskTimeChange, onRemovePlaceholder, onDeleteTask, onUpdateTaskInfo, onUpdateTaskName, timeUnitHeightPx, dayWorkingStartTimeStr, isGhost = false }) => {
            const [isResizing, setIsResizing] = React.useState(false);
            const [resizeStartInfo, setResizeStartInfo] = React.useState(null); // { clientY, originalTime, originalDuration, handleType }
            const [taskInfo, setTaskInfo] = React.useState(task.info || ''); // Local state for task info
            const [isEditingName, setIsEditingName] = React.useState(false);
            const [editedName, setEditedName] = React.useState(task.name);

            // Update local states if task props change
            React.useEffect(() => {
                setTaskInfo(task.info || '');
                setEditedName(task.name);
            }, [task.info, task.name]);

            // Define handleNameChange, handleNameBlur, handleKeyDown for ScheduledTaskItem
            const handleNameChange = (e) => {
                setEditedName(e.target.value);
            };

            const handleNameBlur = () => {
                setIsEditingName(false);
                if (editedName.trim() !== task.name) {
                    onUpdateTaskName(task.id, editedName.trim(), 'scheduled'); // 'scheduled' to indicate it's from scheduled list
                }
            };

            const handleKeyDown = (e) => {
                if (e.key === 'Enter') {
                    e.target.blur(); // Trigger blur to save changes
                }
            };


            // Calculate height and top position for the task item based on pixels per minute
            const pixelsPerMinute = timeUnitHeightPx / 60; // 60 minutes in an hour
            const taskHeight = task.duration * pixelsPerMinute;

            // Calculate start time of the working day in minutes from midnight (for clamping)
            const [startHourWorking, startMinuteWorking] = dayWorkingStartTimeStr.split(':').map(Number);
            const workingStartTimeMinutes = startHourWorking * 60 + startMinuteWorking;

            const minutesFromMidnight = task.time.getHours() * 60 + task.time.getMinutes();
            // Position relative to the *start of the working day*
            const topPosition = (minutesFromMidnight - workingStartTimeMinutes) * pixelsPerMinute;

            // Define minimum height for task content (name, times, info box)
            const MIN_TASK_CONTENT_HEIGHT_PX = 120; // Adjusted minimum height for task content

            // Handler for resizing start (mouse down on handle)
            const handleResizeMouseDown = (e, handleType) => {
                // Prevent resizing for placeholder tasks or ghost tasks
                if (task.isUnaccomplishedPlaceholder || isGhost) return;

                e.stopPropagation(); // Prevent drag of the whole task
                setIsResizing(true);
                setResizeStartInfo({
                    clientY: e.clientY,
                    originalTime: new Date(task.time),
                    originalDuration: task.duration,
                    handleType: handleType,
                });
            };

            // Global mouse move handler for resizing
            const handleGlobalMouseMove = React.useCallback((e) => {
                if (!isResizing || !resizeStartInfo) return;

                const deltaY = e.clientY - resizeStartInfo.clientY;
                // Snap to 5-minute intervals for smoother resizing
                const minutesDelta = Math.round(deltaY / pixelsPerMinute / 5) * 5;

                let newStartTime = new Date(resizeStartInfo.originalTime);
                let newDuration = resizeStartInfo.originalDuration;

                if (resizeStartInfo.handleType === 'bottom') {
                    newDuration = resizeStartInfo.originalDuration + minutesDelta;
                } else if (resizeStartInfo.handleType === 'top') {
                    newStartTime = new Date(resizeStartInfo.originalTime.getTime() + minutesDelta * 60 * 1000);
                    newDuration = resizeStartInfo.originalDuration - minutesDelta;
                }

                // Ensure duration is at least 1 minute
                newDuration = Math.max(1, newDuration);

                // Clamp newStartTime to workingStartTime
                const dayStart = new Date(task.date);
                dayStart.setHours(startHourWorking, startMinuteWorking, 0, 0); // Use workingStartTime as the absolute start
                if (newStartTime.getTime() < dayStart.getTime()) {
                    newStartTime = dayStart;
                    // Adjust duration if start time was capped
                    newDuration = Math.round((resizeStartInfo.originalTime.getTime() + resizeStartInfo.originalDuration * 60 * 1000 - newStartTime.getTime()) / (60 * 1000));
                    newDuration = Math.max(1, newDuration);
                }

                // Ensure end time doesn't go beyond end of day (23:59)
                const endOfDay = new Date(task.date);
                endOfDay.setHours(23, 59, 59, 999);
                const newEndTime = new Date(newStartTime.getTime() + newDuration * 60 * 1000);
                if (newEndTime.getTime() > endOfDay.getTime()) {
                    newDuration = Math.round((endOfDay.getTime() - newStartTime.getTime()) / (60 * 1000));
                    newDuration = Math.max(1, newDuration); // Ensure minimum duration
                }


                // Update the task in the parent state
                onScheduledTaskTimeChange(task.id, newStartTime, newDuration);

            }, [isResizing, resizeStartInfo, task.id, task.date, onScheduledTaskTimeChange, pixelsPerMinute, startHourWorking, startMinuteWorking]);

            // Global mouse up handler for resizing
            const handleGlobalMouseUp = React.useCallback(() => {
                setIsResizing(false);
                setResizeStartInfo(null);
            }, []);

            // Attach/detach global event listeners for resizing
            React.useEffect(() => {
                if (isResizing) {
                    document.addEventListener('mousemove', handleGlobalMouseMove);
                    document.addEventListener('mouseup', handleGlobalMouseUp);
                } else {
                    document.removeEventListener('mousemove', handleGlobalMouseMove);
                    document.removeEventListener('mouseup', handleGlobalMouseUp);
                }
                return () => {
                    document.removeEventListener('mousemove', handleGlobalMouseMove);
                    document.removeEventListener('mouseup', handleGlobalMouseUp);
                };
            }, [isResizing, handleGlobalMouseMove, handleGlobalMouseUp]);


            // Local states for managing input values for start and end times (for manual input)
            const [editedStartTimeStr, setEditedStartTimeStr] = React.useState('');
            const [editedEndTimeStr, setEditedEndTimeStr] = React.useState('');

            // Effect to update local states when task's time or duration changes
            React.useEffect(() => {
                if (task.time) {
                    setEditedStartTimeStr(task.time.toTimeString().substring(0, 5)); // HH:MM format
                    const endTime = new Date(task.time.getTime() + task.duration * 60 * 1000);
                    setEditedEndTimeStr(endTime.toTimeString().substring(0, 5)); // HH:MM format
                } else {
                    setEditedStartTimeStr('');
                    setEditedEndTimeStr('');
                }
            }, [task.time, task.duration]);

            // Handler for manual start time input change
            const handleManualStartTimeChange = (e) => {
                const newTimeStr = e.target.value;
                setEditedStartTimeStr(newTimeStr);

                if (task.time && onScheduledTaskTimeChange) {
                    const [hours, minutes] = newTimeStr.split(':').map(Number);
                    const newStart = new Date(task.date); // Use existing date part
                    newStart.setHours(hours, minutes, 0, 0);

                    // Clamp newStart to workingStartTime
                    const dayStart = new Date(task.date);
                    dayStart.setHours(startHourWorking, startMinuteWorking, 0, 0);
                    if (newStart.getTime() < dayStart.getTime()) {
                        newStart = dayStart;
                    }

                    const currentEndTime = new Date(task.time.getTime() + task.duration * 60 * 1000);
                    const newDurationMs = currentEndTime.getTime() - newStart.getTime();
                    let newDurationMinutes = Math.round(newDurationMs / (60 * 1000));

                    newDurationMinutes = Math.max(1, newDurationMinutes); // Minimum duration

                    if (newDurationMinutes > 0) {
                        onScheduledTaskTimeChange(task.id, newStart, newDurationMinutes);
                    } else {
                        onScheduledTaskTimeChange(task.id, newStart, 1); // Enforce 1 min minimum
                    }
                }
            };

            // Handler for manual end time input change
            const handleManualEndTimeChange = (e) => {
                const newTimeStr = e.target.value;
                setEditedEndTimeStr(newTimeStr);

                if (task.time && onScheduledTaskTimeChange) {
                    const [hours, minutes] = newTimeStr.split(':').map(Number);
                    const newEnd = new Date(task.date); // Use existing date part
                    newEnd.setHours(hours, minutes, 0, 0);

                    const newDurationMs = newEnd.getTime() - task.time.getTime();
                    let newDurationMinutes = Math.round(newDurationMs / (60 * 1000));

                    newDurationMinutes = Math.max(1, newDurationMinutes); // Minimum duration

                    if (newDurationMinutes > 0) {
                        onScheduledTaskTimeChange(task.id, task.time, newDurationMinutes); // Only update duration
                    } else {
                        onScheduledTaskTimeChange(task.id, task.time, 1); // Enforce 1 min minimum
                    }
                }
            };


            return (
                <div
                    id={`scheduled-task-${task.id}`}
                    draggable={!task.isUnaccomplishedPlaceholder && !isGhost} // Make placeholder or ghost non-draggable
                    onDragStart={(e) => {
                        if (isResizing || task.isUnaccomplishedPlaceholder || isGhost) { // Prevent drag if resizing or placeholder/ghost
                            e.preventDefault();
                            return;
                        }
                        onDragStart(e, task, null, 'scheduled');
                    }}
                    onDragEnd={onDragEnd}
                    className={`absolute w-[calc(100%-8px)] left-1 top-0 p-2 rounded-md shadow-sm border border-gray-300 text-gray-800 text-sm flex flex-col scheduled-task-item ${isGhost ? 'is-ghost' : ''}`}
                    style={{
                        backgroundColor: task.isUnaccomplishedPlaceholder ? '#d1d5db' : (isGhost ? '' : '#ffffff'), /* Always white for regular tasks, grey for placeholder, light-blue for ghost */
                        height: `${Math.max(taskHeight, MIN_TASK_CONTENT_HEIGHT_PX)}px`, /* Ensure minimum height */
                        top: `${topPosition}px`,
                        zIndex: isResizing ? 20 : (isGhost ? 10 : 5), /* Bring to front when resizing */
                        cursor: (task.isUnaccomplishedPlaceholder || isGhost) ? 'default' : 'grab', /* Change cursor for placeholder */
                    }}
                >
                    {/* Resize handle top (hidden for placeholders and ghost tasks) */}
                    {!task.isUnaccomplishedPlaceholder && !isGhost && (
                        <div
                            className="resize-handle resize-handle-top"
                            onMouseDown={(e) => handleResizeMouseDown(e, 'top')}
                        ></div>
                    )}

                    <div className="flex justify-between items-center">
                        {isEditingName ? (
                            <input
                                type="text"
                                value={editedName}
                                onChange={handleNameChange}
                                onBlur={handleNameBlur}
                                onKeyDown={handleKeyDown}
                                className="font-semibold w-full bg-gray-100 border border-gray-300 rounded-sm px-1"
                                autoFocus
                                disabled={task.isUnaccomplishedPlaceholder || isGhost}
                            />
                        ) : (
                            <span className="font-semibold cursor-text" onClick={() => !task.isUnaccomplishedPlaceholder && !isGhost && setIsEditingName(true)}>
                                {task.name}
                            </span>
                        )}
                        {/* Time display next to task name */}
                        {task.time && (
                            <span className="text-xs text-gray-500 ml-2">
                                {formatTime(task.time)} - {formatTime(new Date(task.time.getTime() + task.duration * 60 * 1000))}
                            </span>
                        )}
                        {/* Delete button for regular tasks AND placeholder tasks, using the same style (hidden for ghosts) */}
                        {!isGhost && (
                            <button
                                onClick={() => task.isUnaccomplishedPlaceholder ? onRemovePlaceholder(task.id) : onDeleteTask(task.id)}
                                className="delete-task-button"
                                title={task.isUnaccomplishedPlaceholder ? "Remove placeholder" : "Delete task"}
                            >
                                &times;
                            </button>
                        )}
                    </div>
                    {/* Manual Time Change Inputs - always visible (disabled for ghost) */}
                    <div className="flex space-x-1 text-xs text-gray-600 mt-1">
                        <input
                            type="time"
                            value={editedStartTimeStr}
                            onChange={handleManualStartTimeChange}
                            className="p-0.5 text-xs bg-white border border-gray-300 rounded-md w-1/2"
                            title="Change Start Time"
                            disabled={task.isUnaccomplishedPlaceholder || isGhost} /* Disable for placeholders and ghost */
                        />
                        <input
                            type="time"
                            value={editedEndTimeStr}
                            onChange={handleManualEndTimeChange}
                            className="p-0.5 text-xs bg-white border border-gray-300 rounded-md w-1/2"
                            title="Change End Time"
                            disabled={task.isUnaccomplishedPlaceholder || isGhost} /* Disable for placeholders and ghost */
                        />
                    </div>

                    {/* Task Info Textarea (disabled for ghost) */}
                    <textarea
                        value={taskInfo}
                        onChange={(e) => setTaskInfo(e.target.value)}
                        onBlur={() => onUpdateTaskInfo(task.id, taskInfo)} /* Update parent on blur */
                        placeholder="Add task details..."
                        className="w-full text-xs p-1 border border-gray-200 rounded-md overflow-hidden focus:outline-none focus:border-blue-300 mt-1 task-info-textarea" /* Added class for specific styling */
                        rows="2" /* Changed to 2 rows for better visibility */
                        disabled={task.isUnaccomplishedPlaceholder || isGhost} /* Disable for placeholders and ghost */
                        style={{ minHeight: '40px' }} /* Removed fixed height, allowed vertical resize */
                    ></textarea>


                    {/* Resize handle bottom (hidden for placeholders and ghost tasks) */}
                    {!task.isUnaccomplishedPlaceholder && !isGhost && (
                        <div
                            className="resize-handle resize-handle-bottom"
                            onMouseDown={(e) => handleResizeMouseDown(e, 'bottom')}
                        ></div>
                    )}
                </div>
            );
        };

        // TimeSlot Component - Represents a droppable time slot (now just a div for drop target)
        const TimeSlot = ({ time, onDrop, onDragOver, onDragEnter, onDragLeave, isCurrentSlot, timeUnitHeightPx, slotIntervalMinutes }) => {
            const slotHeight = timeUnitHeightPx / (60 / slotIntervalMinutes);

            return (
                <div
                    className={`flex items-start text-gray-700 text-xs ${isCurrentSlot ? 'bg-blue-50' : 'bg-white'}`}
                    onDrop={onDrop}
                    onDragOver={onDragOver}
                    onDragEnter={onDragEnter}
                    onDragLeave={onDragLeave}
                    data-time={time.toISOString()}
                    style={{ height: `${slotHeight}px` }} /* No borderBottom here */
                >
                    <div className="flex-grow min-h-[30px] time-slot-content">
                        {/* Tasks are now absolutely positioned over these slots */}
                    </div>
                </div>
            );
        };

        // Confirmation Modal Component
        const ConfirmationModal = ({ isOpen, onClose, taskName, fromDay, toDay, onConfirmMove, onConfirmDuplicate }) => {
            if (!isOpen) return null;

            return (
                <div className="modal-overlay">
                    <div className="modal-content">
                        <h3 className="text-lg font-semibold mb-4 text-gray-800">Move Task: "{taskName}"</h3>
                        <p className="text-gray-700 mb-6">
                            You are moving this task from <span className="font-medium">{formatDate(fromDay)}</span> to <span className="font-medium">{formatDate(toDay)}</span>.
                            What would you like to do?
                        </p>
                        <div className="flex flex-col space-y-3">
                            <button
                                onClick={() => { onConfirmMove(); onClose(); }}
                                className="w-full bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-4 rounded-md transition duration-300 ease-in-out shadow-md"
                            >
                                Completely Move Task (Not accomplished on {formatDate(fromDay).split(',')[0]})
                            </button>
                            <button
                                onClick={() => { onConfirmDuplicate(); onClose(); }}
                                className="w-full bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-4 rounded-md transition duration-300 ease-in-out shadow-md"
                            >
                                Counting Work on Same Task (Duplicate for {formatDate(toDay).split(',')[0]})
                            </button>
                            <button
                                onClick={onClose}
                                className="w-full bg-gray-300 hover:bg-gray-400 text-gray-800 font-semibold py-2 px-4 rounded-md transition duration-300 ease-in-out shadow-md"
                            >
                                Cancel
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // CurrentTimeIndicator Component
        const CurrentTimeIndicator = ({ timeUnitHeightPx }) => {
            const [top, setTop] = React.useState(0);
            const [currentTimeLabel, setCurrentTimeLabel] = React.useState('');

            const calculatePosition = React.useCallback(() => {
                const now = new Date();
                const minutes = now.getHours() * 60 + now.getMinutes();
                const pixelsPerMinute = timeUnitHeightPx / 60; // 60 minutes in an hour
                setTop(minutes * pixelsPerMinute);
                setCurrentTimeLabel(now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }));
            }, [timeUnitHeightPx]);

            React.useEffect(() => {
                calculatePosition(); // Set initial position
                const interval = setInterval(calculatePosition, 60 * 1000); // Update every minute
                return () => clearInterval(interval); // Cleanup interval on unmount
            }, [calculatePosition]);

            return (
                <div
                    className="current-time-indicator"
                    style={{ top: `${top}px` }}
                >
                    <div className="current-time-circle"></div>
                    <span className="current-time-label">{currentTimeLabel}</span>
                </div>
            );
        };


        // DayColumn Component - Encapsulates a single day's view
        const DayColumn = ({
            dayDate,
            scheduledTasksForDay,
            timeSlotsForDay, // This now represents ALL 30-min slots for the day
            timeUnitHeightPx, // Height for 1 hour
            onDragStart,
            onDragEnd,
            onTimeSlotDrop,
            onTimeSlotDragOver, // New prop for ghost
            onTimeSlotDragEnter, // New prop for ghost
            onTimeSlotDragLeave, // New prop for ghost
            onScheduledTaskTimeChange,
            onRemovePlaceholder,
            onDeleteTask,
            onAddTaskToDay,
            onUpdateTaskInfo, /* Pass onUpdateTaskInfo */
            onUpdateTaskName, /* Pass onUpdateTaskName */
            isCurrentDay,
            workingStartTimeStr, // Pass workingStartTimeStr to DayColumn
            hoveredDayDate, // For ghost
            hoveredSlotTime, // For ghost
            draggingTask // For ghost
        }) => {
            const [showAddTaskForm, setShowAddTaskForm] = React.useState(false);
            const [newTaskName, setNewTaskName] = React.useState('');
            const [newTaskDuration, setNewTaskDuration] = React.useState(30);
            const [newTaskStartTime, setNewTaskStartTime] = React.useState(workingStartTimeStr); // Default to working start time
            
            // Effect to update newTaskStartTime when workingStartTimeStr changes
            React.useEffect(() => {
                setNewTaskStartTime(workingStartTimeStr);
            }, [workingStartTimeStr]);

            const handleAddTaskSubmit = () => {
                if (!newTaskName.trim() || newTaskDuration <= 0) {
                    // Basic validation
                    return;
                }
                // Convert newTaskStartTime string to a Date object for the current day
                const [hours, minutes] = newTaskStartTime.split(':').map(Number);
                const taskDateTime = new Date(dayDate);
                taskDateTime.setHours(hours, minutes, 0, 0);

                onAddTaskToDay(dayDate, newTaskName, newTaskDuration, taskDateTime);
                setShowAddTaskForm(false); // Hide form
                setNewTaskName(''); // Reset form fields
                setNewTaskDuration(30);
                setNewTaskStartTime(workingStartTimeStr); // Reset to working start time
            };

            // Determine which time slots to render for this day (all 30-min slots for grid lines)
            const visibleTimeSlots = React.useMemo(() => {
                // Render all 30-minute slots to create the grid lines
                return timeSlotsForDay;
            }, [timeSlotsForDay]);

            // Ref for the vertical scroll container within this DayColumn
            const dayColumnVerticalScrollRef = React.useRef(null);

            // Effect to scroll to working start time when workingStartTimeStr changes or dayDate changes
            React.useEffect(() => {
                if (dayColumnVerticalScrollRef.current) {
                    const [startHour, startMinute] = workingStartTimeStr.split(':').map(Number);
                    const minutesFromMidnight = (startHour * 60) + startMinute;
                    const pixelsPerMinute = timeUnitHeightPx / 60;
                    const targetScrollTop = minutesFromMidnight * pixelsPerMinute;

                    dayColumnVerticalScrollRef.current.scrollTop = targetScrollTop;
                }
            }, [workingStartTimeStr, dayDate, timeUnitHeightPx]);


            return (
                <div id={`day-${dayDate.toISOString().split('T')[0]}`} className="flex flex-col border border-gray-200 rounded-lg overflow-hidden day-column">
                    <div className="bg-gray-100 p-3 border-b border-gray-200 text-center">
                        <h3 className="font-semibold text-gray-800">{formatDate(dayDate).split(',')[0]}</h3>
                        <p className="text-sm text-gray-600">{formatDate(dayDate).split(',')[1].trim()}</p>
                    </div>
                    <div className="p-2 border-b border-gray-200 text-center">
                        {!showAddTaskForm ? (
                            <button
                                onClick={() => setShowAddTaskForm(true)}
                                className="text-blue-500 hover:text-blue-700 text-sm font-semibold"
                            >
                                + Add task
                            </button>
                        ) : (
                            <div className="bg-gray-50 p-3 rounded-md space-y-2 text-left">
                                <input
                                    type="text"
                                    placeholder="Task Name"
                                    value={newTaskName}
                                    onChange={(e) => setNewTaskName(e.target.value)}
                                    className="w-full px-2 py-1 border rounded-md text-sm"
                                />
                                <input
                                    type="number"
                                    placeholder="Duration (min)"
                                    value={newTaskDuration}
                                    onChange={(e) => setNewTaskDuration(parseInt(e.target.value) || 0)}
                                    min="5"
                                    step="5"
                                    className="w-full px-2 py-1 border rounded-md text-sm"
                                />
                                <input
                                    type="time"
                                    value={newTaskStartTime}
                                    onChange={(e) => setNewTaskStartTime(e.target.value)}
                                    className="w-full px-2 py-1 border rounded-md text-sm"
                                />
                                <div className="flex space-x-2 mt-2">
                                    <button
                                        onClick={handleAddTaskSubmit}
                                        className="flex-1 bg-green-500 hover:bg-green-600 text-white text-xs py-1 rounded-md"
                                    >
                                        Add
                                    </button>
                                    <button
                                        onClick={() => setShowAddTaskForm(false)}
                                        className="flex-1 bg-gray-300 hover:bg-gray-400 text-gray-800 text-xs py-1 rounded-md"
                                    >
                                        Cancel
                                    </button>
                                </div>
                            </div>
                        )}
                    </div>
                    <div ref={dayColumnVerticalScrollRef} className="overflow-y-auto custom-scrollbar flex-grow relative">
                        {/* No horizontal lines rendered here */}
                        {/* TimeSlots are still rendered as invisible drop targets */}
                        {visibleTimeSlots.map((slotTime) => (
                            <TimeSlot
                                key={slotTime.toISOString()}
                                time={slotTime}
                                onDrop={(e) => onTimeSlotDrop(e, dayDate, slotTime, workingStartTimeStr, scheduledTasksForDay)} /* Pass scheduledTasksForDay */
                                onDragOver={(e) => e.preventDefault()}
                                onDragEnter={(e) => onTimeSlotDragEnter(e, dayDate, slotTime)}
                                onDragLeave={(e) => onTimeSlotDragLeave(e, dayDate, slotTime)}
                                isCurrentSlot={isCurrentDay && slotTime.getHours() === new Date().getHours() && (new Date().getMinutes() >= slotTime.getMinutes() && new Date().getMinutes() < (slotTime.getMinutes() + 30))}
                                timeUnitHeightPx={timeUnitHeightPx}
                                slotIntervalMinutes={30}
                            />
                        ))}
                        {/* Render Ghost Task if currently hovering over this day column */}
                        {hoveredDayDate && hoveredSlotTime && draggingTask &&
                            hoveredDayDate.toDateString() === dayDate.toDateString() && (
                                <ScheduledTaskItem
                                    key={`ghost-${draggingTask.id}`} // Unique key for ghost
                                    task={{ ...draggingTask, time: hoveredSlotTime, date: hoveredDayDate }} // Pass current hovered time
                                    onDragStart={() => {}} // Ghost is not draggable
                                    onDragEnd={() => {}}
                                    onScheduledTaskTimeChange={() => {}}
                                    onRemovePlaceholder={() => {}}
                                    onDeleteTask={() => {}}
                                    onUpdateTaskInfo={() => {}}
                                    onUpdateTaskName={() => {}}
                                    timeUnitHeightPx={timeUnitHeightPx}
                                    dayWorkingStartTimeStr={workingStartTimeStr}
                                    isGhost={true} // New prop to style it as a ghost
                                />
                            )}
                        {/* Render actual scheduled tasks */}
                        {scheduledTasksForDay.map((task) => (
                            <ScheduledTaskItem
                                key={task.id}
                                task={task}
                                onDragStart={onDragStart}
                                onDragEnd={onDragEnd}
                                onScheduledTaskTimeChange={onScheduledTaskTimeChange}
                                onRemovePlaceholder={onRemovePlaceholder}
                                onDeleteTask={onDeleteTask}
                                onUpdateTaskInfo={onUpdateTaskInfo}
                                onUpdateTaskName={onUpdateTaskName} /* Pass onUpdateTaskName */
                                timeUnitHeightPx={timeUnitHeightPx}
                                dayWorkingStartTimeStr={workingStartTimeStr}
                            />
                        ))}
                        {isCurrentDay && <CurrentTimeIndicator timeUnitHeightPx={timeUnitHeightPx} />}
                    </div>
                </div>
            );
        };


        // Main App component for the web application
        const App = () => {
            const [message, setMessage] = React.useState('');
            const [isLoading, setIsLoading] = React.useState(false);

            // Define the height of a single hour in pixels
            const TIME_UNIT_HEIGHT_PX = 60; // 60px represents 1 hour

            // State for managing the currently viewed date range
            const [centralViewDate, setCentralViewDate] = React.useState(new Date());
            const NUM_DAYS_TO_RENDER = 7; // Render 7 days at a time (e.g., 3 before, central, 3 after)

            // Task states with initial colors
            const [topTasks, setTopTasks] = React.useState([
                { id: 'tt1', name: 'Review PRs', duration: 60, info: '' },
                { id: 'tt2', name: 'Prepare for Meeting', duration: 30, info: '' },
                { id: 'tt3', name: 'Respond to Emails', duration: 45, info: '' },
                { id: 'tt4', name: 'Code Feature X', duration: 90, info: '' },
                { id: 'tt5', name: 'Research Topic Y', duration: 60, info: '' },
                { id: 'tt6', name: 'Team Sync', duration: 30, info: '' },
                { id: 'tt7', name: 'Client Call', duration: 60, info: '' },
            ]);
            const [dumpedTasks, setDumpedTasks] = React.useState([
                { id: 'dt1', name: 'Organize files', duration: 30, info: '' },
                { id: 'dt2', name: 'Plan weekend', duration: 15, info: '' },
                { id: 'dt3', name: 'Call client Z', duration: 20, info: '' },
                { id: 'dt4', name: 'Read article', duration: 40, info: '' },
                { id: 'dt5', name: 'Brainstorm ideas', duration: 60, info: '' },
                { id: 'dt6', name: 'Update resume', duration: 90, info: '' },
                { id: 'dt7', name: 'Research new tech', duration: 45, info: '' },
                { id: 'dt8', name: 'Clean desk', duration: 15, info: '' },
                { id: 'dt9', name: 'Review budget', duration: 30, info: '' },
                { id: 'dt10', name: 'Learn new skill', duration: 60, info: '' },
                { id: 'dt11', name: 'Prepare dinner', duration: 30, info: '' },
                { id: 'dt12', name: 'Exercise', duration: 45, info: '' },
                { id: 'dt13', name: 'Meditate', duration: 15, info: '' },
                { id: 'dt14', name: 'Read book', duration: 60, info: '' },
                { id: 'dt15', name: 'Write journal', duration: 20, info: '' },
            ]);
            // Scheduled tasks will now have a 'date' property (Date object for the day) and a 'time' property (Date object for exact time)
            const [scheduledTasks, setScheduledTasks] = React.useState([]);

            // State for adding new tasks to dump
            const [newTaskName, setNewTaskName] = React.useState('');
            const [newTaskDuration, setNewTaskDuration] = React.useState(30);

            // Drag and Drop states
            const [draggingTask, setDraggingTask] = React.useState(null); // The task being dragged
            const [draggedFromList, setDraggedFromList] = React.useState(null); // 'top', 'dumped', or 'scheduled'
            const [hoveredDayDate, setHoveredDayDate] = React.useState(null); // For ghost
            const [hoveredSlotTime, setHoveredSlotTime] = React.useState(null); // For ghost

            // Modal states
            const [isModalOpen, setIsModalOpen] = React.useState(false);
            const [modalTaskInfo, setModalTaskInfo] = React.useState(null); // { task, fromDay, toDay, slotTime }

            // Ref for the scrollable day container (horizontal scroll)
            const dayColumnsRef = React.useRef(null);
            // Ref for the vertical scroll container of today's column (for auto-scroll)
            const todayVerticalScrollRef = React.useRef(null);

            const COLUMN_WIDTH_PX = 300; // Must match .day-column width in CSS

            // Generate days based on centralViewDate
            const generateDays = React.useCallback((centralDate, numDays) => {
                const daysArray = [];
                const startDayOffset = Math.floor(numDays / 2); // How many days before central date

                for (let i = -startDayOffset; i < numDays - startDayOffset; i++) {
                    const dayDate = new Date(centralDate);
                    dayDate.setDate(centralDate.getDate() + i);
                    dayDate.setHours(0, 0, 0, 0); // Normalize to start of day
                    daysArray.push(dayDate);
                }
                return daysArray;
            }, []);

            const days = React.useMemo(() => generateDays(centralViewDate, NUM_DAYS_TO_RENDER), [centralViewDate, generateDays]);

            // Generate ALL 30-minute time slots for a given day (used internally for calculations)
            const generateAllTimeSlotsForDay = React.useCallback((dayDate) => {
                const slots = [];
                const startOfDay = new Date(dayDate);
                startOfDay.setHours(0, 0, 0, 0); // Start day at 0 AM for full range

                const endOfDayHour = 24; // End day at 24 (just before next day)

                for (let i = 0; i < (endOfDayHour) * 2; i++) { // 24 hours * 2 intervals = 48 slots
                    const slotTime = new Date(startOfDay.getTime() + i * 30 * 60 * 1000);
                    slots.push(slotTime);
                }
                return slots;
            }, []);

            // Function to scroll to today's column and current time
            const scrollToToday = React.useCallback(() => {
                const today = new Date();
                const todayString = today.toISOString().split('T')[0];
                const todayColumnElement = document.getElementById(`day-${todayString}`);

                if (todayColumnElement && dayColumnsRef.current) {
                    const scrollContainer = dayColumnsRef.current;
                    const todayColumnOffset = todayColumnElement.offsetLeft;
                    
                    // Set horizontal scroll to make today's column leftmost
                    scrollContainer.scrollLeft = todayColumnOffset;

                    // Scroll to current time within today's column (vertical scroll)
                    const currentHour = today.getHours();
                    const currentMinute = today.getMinutes();
                    const minutesFromDayStart = (currentHour * 60) + currentMinute; // Minutes from 00:00

                    const pixelsPerMinute = TIME_UNIT_HEIGHT_PX / 60;
                    const targetScrollTop = minutesFromDayStart * pixelsPerMinute;

                    // Get the vertical scrollable div within today's column
                    const dayColumnVerticalScrollDiv = todayColumnElement.querySelector('.overflow-y-auto');
                    if (dayColumnVerticalScrollDiv) {
                        const visibleHeight = dayColumnVerticalScrollDiv.clientHeight;
                        // Position current time line at 1/3 from top of visible area
                        dayColumnVerticalScrollDiv.scrollTop = targetScrollTop - (visibleHeight * (1/3));
                    }
                }
            }, [days, TIME_UNIT_HEIGHT_PX]); // Added TIME_UNIT_HEIGHT_PX to dependencies

            // Scroll to current time for the "Today" column on initial load
            React.useEffect(() => {
                scrollToToday();
            }, [days, scrollToToday]);


            // Handle horizontal scrolling for infinite days
            const handleHorizontalScroll = React.useCallback(() => {
                const container = dayColumnsRef.current;
                if (!container) return;

                const scrollLeft = container.scrollLeft;
                const scrollWidth = container.scrollWidth;
                const clientWidth = container.clientWidth;

                const scrollThreshold = COLUMN_WIDTH_PX * (NUM_DAYS_TO_RENDER / 4); // Load new days when near 1/4 of the visible days

                // Scrolling left (towards past days)
                if (scrollLeft < scrollThreshold && scrollLeft > 0) {
                    setCentralViewDate(prevDate => {
                        const newDate = new Date(prevDate);
                        newDate.setDate(newDate.getDate() - (NUM_DAYS_TO_RENDER / 2));
                        return newDate;
                    });
                    container.scrollLeft += COLUMN_WIDTH_PX * (NUM_DAYS_TO_RENDER / 2);
                }
                // Scrolling right (towards future days)
                else if (scrollLeft + clientWidth > scrollWidth - scrollThreshold) {
                    setCentralViewDate(prevDate => {
                        const newDate = new Date(prevDate);
                        newDate.setDate(newDate.getDate() + (NUM_DAYS_TO_RENDER / 2));
                        return newDate;
                    });
                    container.scrollLeft -= COLUMN_WIDTH_PX * (NUM_DAYS_TO_RENDER / 2);
                }
            }, [NUM_DAYS_TO_RENDER]);

            React.useEffect(() => {
                const container = dayColumnsRef.current;
                if (container) {
                    container.addEventListener('scroll', handleHorizontalScroll);
                }
                return () => {
                    if (container) {
                        container.removeEventListener('scroll', handleHorizontalScroll);
                    }
                };
            }, [handleHorizontalScroll]);


            // Drag start handler
            const handleDragStart = (e, task, index, listType) => {
                e.dataTransfer.setData('text/plain', task.id);
                setDraggingTask(task);
                setDraggedFromList(listType);
                e.currentTarget.classList.add('opacity-50');
            };

            // Drag end handler (for cleanup)
            const handleDragEnd = (e) => {
                e.currentTarget.classList.remove('opacity-50');
                setDraggingTask(null);
                setDraggedFromList(null);
                setHoveredDayDate(null); // Clear hovered state on drag end
                setHoveredSlotTime(null); // Clear hovered state on drag end
            };

            // Drag over handler for droppable areas
            const handleDragOver = (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            };

            // Drag Enter handler for time slots (for ghost task)
            const handleTimeSlotDragEnter = (e, dayDate, slotTime) => {
                e.preventDefault();
                if (draggingTask) {
                    setHoveredDayDate(dayDate);
                    setHoveredSlotTime(slotTime);
                }
            };

            // Drag Leave handler for time slots (for ghost task)
            const handleTimeSlotDragLeave = (e, dayDate, slotTime) => {
                // To avoid flickering, only clear if truly leaving the calendar or if another slot handles dragenter
                // For simplicity, we rely on dragOver of the next slot to update.
            };


            // Drop handler for time slots in a specific day
            const handleTimeSlotDrop = (e, dayDate, slotTime, dayWorkingStartTimeStr, scheduledTasksForDay) => {
                e.preventDefault();
                if (!draggingTask) return;

                // Clear ghost on drop
                setHoveredDayDate(null);
                setHoveredSlotTime(null);

                const dayColumnRect = e.currentTarget.closest('.day-column').getBoundingClientRect();
                const dayColumnContent = e.currentTarget.closest('.day-column').querySelector('.overflow-y-auto');
                const dayColumnScrollTop = dayColumnContent ? dayColumnContent.scrollTop : 0;

                const dropY = e.clientY - dayColumnRect.top + dayColumnScrollTop;

                const pixelsPerMinute = TIME_UNIT_HEIGHT_PX / 60;
                let minutesFromMidnight = Math.round(dropY / pixelsPerMinute / 5) * 5;

                let dropTime = new Date(dayDate);
                dropTime.setHours(Math.floor(minutesFromMidnight / 60), minutesFromMidnight % 60, 0, 0);

                let finalDropTime = new Date(dropTime); // Default to visual drop time

                if (draggedFromList !== 'scheduled') { // This logic applies only for new tasks from left panel
                    const existingTasksOnTargetDay = scheduledTasks.filter(
                        t => t.date && t.date.toDateString() === dayDate.toDateString() && !t.isUnaccomplishedPlaceholder
                    ).sort((a, b) => a.time.getTime() - b.time.getTime());

                    if (existingTasksOnTargetDay.length > 0) {
                        // Find the end time of the last task on that day
                        const lastTask = existingTasksOnTargetDay[existingTasksOnTargetDay.length - 1];
                        const lastTaskEndTime = new Date(lastTask.time.getTime() + lastTask.duration * 60 * 1000);

                        // If the calculated dropTime is before or overlaps with the last task's end time,
                        // place the new task immediately after the last task.
                        if (finalDropTime.getTime() < lastTaskEndTime.getTime()) {
                            finalDropTime = lastTaskEndTime;
                        }
                        // else, if finalDropTime is after lastTaskEndTime, it means dropping into empty space later in the day,
                        // so we use the original finalDropTime.
                    }
                }

                // Now, clamp finalDropTime to workingStartTime (this should apply to both new and moved tasks)
                const [startHourWorking, startMinuteWorking] = dayWorkingStartTimeStr.split(':').map(Number);
                const workingStartTimeMillis = new Date(dayDate);
                workingStartTimeMillis.setHours(startHourWorking, startMinuteWorking, 0, 0);

                if (finalDropTime.getTime() < workingStartTimeMillis.getTime()) {
                    finalDropTime = new Date(workingStartTimeMillis);
                }

                // Ensure the task's end time doesn't exceed 23:59 on the target day
                const endOfDay = new Date(dayDate);
                endOfDay.setHours(23, 59, 59, 999);
                let proposedTaskEndTime = new Date(finalDropTime.getTime() + draggingTask.duration * 60 * 1000);

                if (proposedTaskEndTime.getTime() > endOfDay.getTime()) {
                    // If the task would extend past end of day, adjust its start time to fit, maintaining duration.
                    // Calculate a new start time that places it just before the end of the day.
                    finalDropTime = new Date(endOfDay.getTime() - draggingTask.duration * 60 * 1000);
                    // Ensure it doesn't go before working start if pushed back too much
                    if (finalDropTime.getTime() < workingStartTimeMillis.getTime()) {
                        finalDropTime = new Date(workingStartTimeMillis);
                        // If it still cannot fit even by starting at working start, the duration needs to be clipped
                        // but ScheduledTaskItem's resize logic already handles min duration.
                    }
                }


                // Check if it's a cross-day move for a scheduled task
                if (draggedFromList === 'scheduled' && draggingTask.date && draggingTask.date.toDateString() !== dayDate.toDateString()) {
                    setModalTaskInfo({ task: draggingTask, fromDay: draggingTask.date, toDay: dayDate, slotTime: finalDropTime }); // Use finalDropTime here
                    setIsModalOpen(true);
                    return;
                }

                handleTaskMovement(draggingTask, draggedFromList, dayDate, finalDropTime); // Use finalDropTime
            };

            // Centralized function to handle task movement based on modal choice or direct drop
            const handleTaskMovement = (taskToMove, originalListType, targetDayDate, targetSlotTime, isDuplicate = false) => {
                const newScheduledTask = {
                    ...taskToMove,
                    id: isDuplicate ? `duplicate-${taskToMove.id}-${Date.now()}` : taskToMove.id,
                    name: isDuplicate ? `${taskToMove.name} (Cont.)` : taskToMove.name,
                    date: targetDayDate,
                    time: targetSlotTime,
                    info: taskToMove.info || '',
                };

                setScheduledTasks(prev => {
                    let updated = [...prev];

                    if (originalListType === 'scheduled') {
                        const isCrossDayMove = taskToMove.date && taskToMove.date.toDateString() !== targetDayDate.toDateString();

                        if (isCrossDayMove && !isDuplicate) {
                            const originalTaskIndex = updated.findIndex(t => t.id === taskToMove.id && t.date.toDateString() === taskToMove.date.toDateString());
                            if (originalTaskIndex !== -1) {
                                updated[originalTaskIndex] = {
                                    id: `placeholder-${taskToMove.id}-${Date.now()}`,
                                    name: `${taskToMove.name} (Unaccomplished)`,
                                    duration: taskToMove.duration,
                                    date: taskToMove.date,
                                    time: taskToMove.time,
                                    info: taskToMove.info || '',
                                    isUnaccomplishedPlaceholder: true,
                                };
                            }
                        } else if (!isCrossDayMove && !isDuplicate) {
                            // If it's a move within the same day or a direct re-placement, remove the old one first
                            updated = updated.filter(t => !(t.id === taskToMove.id && t.date.toDateString() === taskToMove.date.toDateString()));
                        }
                    } else if (originalListType === 'top') {
                        setTopTasks(prevTop => prevTop.filter(t => t.id !== taskToMove.id));
                    } else if (originalListType === 'dumped') {
                        setDumpedTasks(prevDumped => prevDumped.filter(t => t.id !== taskToMove.id));
                    }

                    updated.push(newScheduledTask);

                    return updated.sort((a, b) => {
                        if (a.date.getTime() !== b.date.getTime()) {
                            return a.date.getTime() - b.date.getTime();
                        }
                        return a.time.getTime() - b.time.getTime();
                    });
                });

                setMessage(`"${newScheduledTask.name}" scheduled for ${formatDate(targetDayDate)} at ${formatTime(targetSlotTime)}.`);
            };

            // Modal confirmation handlers
            const confirmMoveTask = () => {
                if (modalTaskInfo) {
                    handleTaskMovement(modalTaskInfo.task, 'scheduled', modalTaskInfo.toDay, modalTaskInfo.slotTime, false);
                }
            };

            const confirmDuplicateTask = () => {
                if (modalTaskInfo) {
                    handleTaskMovement(modalTaskInfo.task, 'none', modalTaskInfo.toDay, modalTaskInfo.slotTime, true);
                    setMessage(`"${modalTaskInfo.task.name} (Cont.)" continued on ${formatDate(modalTaskInfo.toDay)}.`);
                }
            };

            // Function to remove a placeholder task
            const handleRemovePlaceholder = (taskId) => {
                setScheduledTasks(prev => prev.filter(task => task.id !== taskId));
                setMessage('Unaccomplished task placeholder removed.');
            };

            // Function to delete any scheduled task (newly added)
            const handleDeleteTask = (taskId) => {
                setScheduledTasks(prev => prev.filter(task => task.id !== taskId));
                setMessage('Task deleted.');
            };

            // Function to add a new task to the Dumped Tasks list (left panel)
            const handleAddTaskToDump = () => {
                if (!newTaskName.trim()) {
                    setMessage('Please enter a task name for the new task.');
                    return;
                }
                if (newTaskDuration <= 0) {
                    setMessage('New task duration must be a positive number.');
                    return;
                }

                const newId = `dt-${Date.now()}`;
                const taskToAdd = {
                    id: newId,
                    name: newTaskName.trim(),
                    duration: newTaskDuration,
                    info: '', // Initialize info for new tasks
                };

                setDumpedTasks(prev => [...prev, taskToAdd]);
                setNewTaskName('');
                setNewTaskDuration(30);
                setMessage(`"${taskToAdd.name}" added to Dumped Tasks.`);
            };

            // Dummy function for syncing dumped tasks (can be expanded)
            const syncDumpedTasks = () => {
                setMessage('Syncing dumped tasks... (Feature to be implemented)');
                setTimeout(() => {
                    setDumpedTasks([]);
                    setMessage('Dumped tasks synced! (Cleared locally)');
                }, 1500);
            };

            // Function to add a task directly to a specific day (from DayColumn)
            const handleAddTaskToDay = (dayDate, name, duration, startTime) => {
                const newId = `scheduled-${Date.now()}`;
                const newTask = {
                    id: newId,
                    name,
                    duration,
                    date: dayDate,
                    time: startTime,
                    info: '', // Initialize info for tasks added directly to day
                };
                setScheduledTasks(prev => {
                    const updated = [...prev, newTask];
                    return updated.sort((a, b) => {
                        if (a.date.getTime() !== b.date.getTime()) {
                            return a.date.getTime() - b.date.getTime();
                        }
                        return a.time.getTime() - b.time.getTime();
                    });
                });
                setMessage(`"${name}" added to ${formatDate(dayDate)}.`);
            };

            // Function to manually adjust time or duration for a scheduled task (used by ScheduledTaskItem)
            const handleScheduledTaskTimeChange = (taskId, newTime, newDuration) => {
                setScheduledTasks(prev => prev.map(task => {
                    if (task.id === taskId) {
                        const updatedTime = new Date(task.date);
                        updatedTime.setHours(newTime.getHours(), newTime.getMinutes(), 0, 0);

                        return {
                            ...task,
                            time: updatedTime,
                            duration: newDuration,
                        };
                    }
                    return task;
                }).sort((a, b) => {
                    if (a.date.getTime() !== b.date.getTime()) {
                        return a.date.getTime() - b.date.getTime();
                    }
                    return a.time.getTime() - b.time.getTime();
                }));
            };

            // Function to update task's info (used by ScheduledTaskItem)
            const handleUpdateTaskInfo = (taskId, newInfo) => {
                setScheduledTasks(prev => prev.map(task => {
                    if (task.id === taskId) {
                        return { ...task, info: newInfo };
                    }
                    return task;
                }));
            };

            // Function to update task's name (used by TaskItem and ScheduledTaskItem)
            const handleUpdateTaskName = (taskId, newName, listType) => {
                if (listType === 'left') { // For Top Tasks and Brain Dump
                    setTopTasks(prev => prev.map(task => task.id === taskId ? { ...task, name: newName } : task));
                    setDumpedTasks(prev => prev.map(task => task.id === taskId ? { ...task, name: newName } : task));
                } else if (listType === 'scheduled') { // For scheduled tasks
                    setScheduledTasks(prev => prev.map(task => task.id === taskId ? { ...task, name: newName } : task));
                }
            };

            // Helper for current slot highlighting
            const isCurrentSlot = (dayDate, slotTime) => {
                const now = new Date();
                return dayDate.toDateString() === now.toDateString() &&
                        slotTime.getHours() === now.getHours() &&
                       (now.getMinutes() >= slotTime.getMinutes() && now.getMinutes() < (slotTime.getMinutes() + 30));
            };

            // Function to scroll the day columns left/right
            const scrollDays = (direction) => {
                if (dayColumnsRef.current) {
                    const scrollAmount = COLUMN_WIDTH_PX;
                    dayColumnsRef.current.scrollBy({
                        left: direction === 'left' ? -scrollAmount : scrollAmount,
                        behavior: 'smooth'
                    });
                }
            };

            // State for toggling visibility of sections
            const [isTopTasksVisible, setIsTopTasksVisible] = React.useState(true);
            const [isBrainDumpVisible, setIsBrainDumpVisible] = React.useState(true);

            // State for working hours
            const [workingStartTime, setWorkingStartTime] = React.useState('07:00'); // Default working start time for the day
            const [workingEndTime, setWorkingEndTime] = React.useState('19:00'); // Default working end time for the day

            return (
                <div className="p-4 bg-gray-50 flex flex-col md:flex-row md:space-x-4 space-y-4 md:space-y-0 w-full min-h-[calc(100vh-40px)]">
                    {/* Left Panel: Task Management */}
                    <div className="flex-shrink-0 w-full md:w-80 flex flex-col space-y-4">
                        {/* Today's Date Display */}
                        <div className="bg-white p-4 rounded-lg shadow-md border border-gray-200 text-center">
                            <h2 className="text-lg font-semibold text-gray-800">Today is</h2>
                            <p className="text-xl font-bold text-blue-600">{formatFullDate(new Date())}</p>
                        </div>

                        {/* Top Tasks */}
                        <div className="bg-white p-4 rounded-lg shadow-md border border-gray-200 flex-grow">
                            <div className="flex justify-between items-center mb-3">
                                <h2 className="text-lg font-semibold text-gray-800">Top Tasks</h2>
                                <button
                                    onClick={() => setIsTopTasksVisible(!isTopTasksVisible)}
                                    className="text-gray-500 hover:text-gray-700 text-sm font-bold"
                                >
                                    {isTopTasksVisible ? 'v' : '>'}
                                </button>
                            </div>
                            {isTopTasksVisible && (
                                <div className="space-y-2 custom-scrollbar overflow-y-auto max-h-[322px]">
                                    {topTasks.length === 0 && <p className="text-gray-500 text-sm">No top tasks. Drag from dump or add new.</p>}
                                    {topTasks.map((task, index) => (
                                        <TaskItem
                                            key={task.id}
                                            task={task}
                                            index={index}
                                            onDragStart={(e, t, idx) => handleDragStart(e, t, idx, 'top')}
                                            onDragEnd={handleDragEnd}
                                            onUpdateTaskName={handleUpdateTaskName} /* Pass update handler */
                                        />
                                    ))}
                                </div>
                            )}
                        </div>

                        {/* Brain Dump */}
                        <div className="bg-white p-4 rounded-lg shadow-md border border-gray-200 flex-grow">
                            <div className="flex justify-between items-center mb-3">
                                <h2 className="text-lg font-semibold text-gray-800">Brain Dump</h2>
                                <button
                                    onClick={() => setIsBrainDumpVisible(!isBrainDumpVisible)}
                                    className="text-gray-500 hover:text-gray-700 text-sm font-bold"
                                >
                                    {isBrainDumpVisible ? 'v' : '>'}
                                </button>
                            </div>
                            {isBrainDumpVisible && (
                                <div className="space-y-2 custom-scrollbar overflow-y-auto max-h-[690px]">
                                    {dumpedTasks.length === 0 && <p className="text-gray-500 text-sm">No dumped tasks. Add new ones!</p>}
                                    {dumpedTasks.map((task, index) => (
                                        <TaskItem
                                            key={task.id}
                                            task={task}
                                            index={index}
                                            onDragStart={(e, t, idx) => handleDragStart(e, t, idx, 'dumped')}
                                            onDragEnd={handleDragEnd}
                                            onUpdateTaskName={handleUpdateTaskName} /* Pass update handler */
                                        />
                                    ))}
                                </div>
                            )}
                            <button
                                onClick={syncDumpedTasks}
                                className="mt-4 w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-md transition duration-300 ease-in-out focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 shadow-md"
                            >
                                Sync Dumped Tasks
                            </button>
                        </div>

                        {/* Add New Task Section (for dumping) */}
                        <div className="bg-white p-4 rounded-lg shadow-md border border-gray-200">
                            <h2 className="text-lg font-semibold text-gray-800 mb-3">Add New Task to Dump</h2>
                            <div className="space-y-3">
                                <div>
                                    <label htmlFor="newTaskName" className="block text-sm font-medium text-gray-700 mb-1">
                                        Task Name
                                    </label>
                                    <input
                                        type="text"
                                        id="newTaskName"
                                        value={newTaskName}
                                        onChange={(e) => setNewTaskName(e.target.value)}
                                        placeholder="e.g., Plan next sprint"
                                        className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 text-gray-800"
                                    />
                                </div>
                                <div>
                                    <label htmlFor="newTaskDuration" className="block text-sm font-medium text-gray-700 mb-1">
                                        Duration (minutes)
                                    </label>
                                    <input
                                        type="number"
                                        id="newTaskDuration"
                                        value={newTaskDuration}
                                        onChange={(e) => setNewTaskDuration(parseInt(e.target.value) || 0)}
                                        min="5"
                                        step="5"
                                        className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 text-gray-800"
                                    />
                                </div>
                                <button
                                    onClick={handleAddTaskToDump}
                                    className="w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-md transition duration-300 ease-in-out focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-50 shadow-md"
                                >
                                    Add Task to Dump
                                </button>
                            </div>
                        </div>
                    </div>

                    {/* Right Panel: Multi-Day Time Slots */}
                    <div className="flex-1 bg-white p-4 rounded-lg shadow-md border border-gray-200 overflow-hidden flex flex-col">
                        <div className="flex justify-between items-center mb-3">
                            <h2 className="text-lg font-semibold text-gray-800">Board</h2>
                            <div className="flex space-x-2">
                                <button
                                    onClick={() => scrollDays('left')}
                                    className="px-3 py-1 bg-gray-200 rounded-md text-sm text-gray-700 hover:bg-gray-300"
                                >
                                    &lt;
                                </button>
                                <button
                                    onClick={scrollToToday}
                                    className="px-3 py-1 bg-gray-200 rounded-md text-sm text-gray-700 hover:bg-gray-300"
                                >
                                    Today
                                </button>
                                <button
                                    onClick={() => scrollDays('right')}
                                    className="px-3 py-1 bg-gray-200 rounded-md text-sm text-gray-700 hover:bg-gray-300"
                                >
                                    &gt;
                                </button>
                                <button className="px-3 py-1 bg-gray-200 rounded-md text-sm text-gray-700 hover:bg-gray-300">Filter</button>
                            </div>
                        </div>

                        {/* Working Time Inputs */}
                        <div className="flex justify-center items-center space-x-2 mb-4 p-2 bg-gray-50 rounded-md border border-gray-200">
                            <label htmlFor="workingStartTime" className="text-sm font-medium text-gray-700">Work Start:</label>
                            <input
                                type="time"
                                id="workingStartTime"
                                value={workingStartTime}
                                onChange={(e) => setWorkingStartTime(e.target.value)}
                                className="px-2 py-1 border rounded-md text-sm"
                            />
                            <label htmlFor="workingEndTime" className="text-sm font-medium text-gray-700">Work End:</label>
                            <input
                                type="time"
                                id="workingEndTime"
                                value={workingEndTime}
                                onChange={(e) => setWorkingEndTime(e.target.value)}
                                className="px-2 py-1 border rounded-md text-sm"
                            />
                        </div>

                        <div ref={dayColumnsRef} className="flex flex-nowrap overflow-x-scroll custom-scrollbar flex-grow">
                            {days.map((dayDate, dayIndex) => (
                                <DayColumn
                                    key={dayDate.toISOString()}
                                    dayDate={dayDate}
                                    scheduledTasksForDay={scheduledTasks.filter(task => task.date && task.date.toDateString() === dayDate.toDateString())}
                                    timeSlotsForDay={generateAllTimeSlotsForDay(dayDate)}
                                    timeUnitHeightPx={TIME_UNIT_HEIGHT_PX}
                                    onDragStart={handleDragStart}
                                    onDragEnd={handleDragEnd}
                                    onTimeSlotDrop={(e, date, slot, scheduledTasksForDay) => handleTimeSlotDrop(e, date, slot, workingStartTime, scheduledTasksForDay)}
                                    onTimeSlotDragOver={handleDragOver} // Use generic dragOver for time slots
                                    onTimeSlotDragEnter={handleTimeSlotDragEnter} // New prop
                                    onTimeSlotDragLeave={handleTimeSlotDragLeave} // New prop
                                    onScheduledTaskTimeChange={handleScheduledTaskTimeChange}
                                    onRemovePlaceholder={handleRemovePlaceholder}
                                    onDeleteTask={handleDeleteTask}
                                    onAddTaskToDay={handleAddTaskToDay}
                                    onUpdateTaskInfo={handleUpdateTaskInfo}
                                    onUpdateTaskName={handleUpdateTaskName}
                                    isCurrentDay={dayDate.toDateString() === new Date().toDateString()}
                                    workingStartTimeStr={workingStartTime}
                                    hoveredDayDate={hoveredDayDate} // Pass to DayColumn
                                    hoveredSlotTime={hoveredSlotTime} // Pass to DayColumn
                                    draggingTask={draggingTask} // Pass to DayColumn
                                />
                            ))}
                        </div>
                    </div>

                    {/* Message display area */}
                    {message && (
                        <p className={`absolute bottom-4 left-1/2 -translate-x-1/2 p-2 rounded-md shadow-lg text-sm font-medium text-center ${message.includes('failed') || message.includes('Error') ? 'bg-red-100 text-red-700' : 'bg-green-100 text-green-700'}`}>
                            {message}
                        </p>
                    )}

                    {/* Confirmation Modal */}
                    {isModalOpen && modalTaskInfo && (
                        <ConfirmationModal
                            isOpen={isModalOpen}
                            onClose={() => setIsModalOpen(false)}
                            taskName={modalTaskInfo.task.name}
                            fromDay={modalTaskInfo.fromDay}
                            toDay={modalTaskInfo.toDay}
                            onConfirmMove={confirmMoveTask}
                            onConfirmDuplicate={confirmDuplicateTask}
                        />
                    )}
                </div>
            );
        };

        // Render the App component into the root div
        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
